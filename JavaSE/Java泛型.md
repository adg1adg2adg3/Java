## 泛型：（变量类型还不确定时使用，在声明时把变量类型换成<变量代称>）
    类定义（整个类都是泛型）：
    权限 class 泛型名称<变量代称>{
    权限 变量代称 变量名称;		//成员变量定义
    权限 返回值类型 方法名称(参数列表...) {		//成员方法定义
        .....								//注意返回值类型和参数列表
    }										//中包括变量代称。
    }
    调用方法与ArrayList类似。Java语法.note

    下面返回值类型前要加<变量代称>说明此方法为泛型
    方法定义（类不是泛型）：
    权限 <变量代称> 返回值类型 方法名称（参数列表...）{
        .....
    }
    往方法里传递什么类型，方法就是什么类型，不用特意指定变量类型。
    也可以定义多种变量类型：public class Pair<T, U> { . . . }
    可以对类型设限<T extends 某某类或接口>，多个类或接口时用&分隔，最多限定一个类，且类要写在前面。

    静态方法定义（类不是泛型无所谓）：
    权限 static <变量代称> 返回值类型 方法名称（参数列表...）{
    }

    接口泛型：
    接口定义：
    权限 interface 接口名称<变量代称>{
    权限 abstract 返回值类型 方法名称(参数列表);
    }

    
[comment]: <> (类型擦除) 

    实现类定义(实现类指定接口的泛型)：
    权限 class 类名称 implements 接口名称<变量类型>{
        ......
    }
    (构造时指定接口的泛型)
    权限 class 泛型名称<变量代称> extends 父类名称<变量代称> implements 接口名称<变量代称>{
    .    ......
    }

    泛型通配符："?"
    "?"代表任意数据类型，不能用来创建对象，作为方法的参数使用。
    一旦使用，只能使用Object类中的共有方法，子类中的特有方法无法使用。
    注意：在方法中泛型变量无继承概念，即<int>与<Object>无继承关系。

    泛型的限定：
    上限： "？ extends E " ：代表使用的泛型只能是E类型或E类型的子类
    下限： "？ super E"	     ：代表使用的泛型只能是E类型或E类型的父类